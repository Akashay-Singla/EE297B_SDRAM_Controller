// ============================================================================
//   Ver  :| Author					:| Mod. Date :| Changes Made:
//   V1.1 :| Alexandra Du			:| 06/01/2016:| Added Verilog file
// ============================================================================


//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================


module DE10_LITE_Golden_Top(
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,
	output reg	    [12:0]		DRAM_ADDR,
	output reg	    [1:0]		DRAM_BA,
	output reg		          	DRAM_CAS_N,
	output reg		          	DRAM_CKE,
	output    	               DRAM_CLK,
	output reg           		DRAM_CS_N,
	inout  reg  	[15:0]	   DRAM_DQ,
	output reg	          		DRAM_LDQM,
	output reg            	   DRAM_RAS_N,
	output reg	          		DRAM_UDQM,
	output reg	            	DRAM_WE_N,
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,
	input 		     [1:0]		KEY,
	output	reg	  [9:0]		LEDR,
	input 		     [9:0]		SW,
	inout 		          		ARDUINO_RESET_N,
	inout 		    [35:0]		GPIO
);
reg [3:0] command; 

reg [4:0] state,nstate;
reg [15:0] data_in,data_in_ff,data_out,DRAM_DQ_temp;
reg [12:0] addr;
reg [19:0] init_count;
reg [1:0] precharge_count;
reg [3:0] refresh_count;
reg [2:0] nop_count;
wire clk,rst;
assign DRAM_CLK = MAX10_CLK1_50;
assign clk = MAX10_CLK1_50;
assign rst = KEY[0];
assign HEX0 = numdisp(DRAM_DQ[3:0]);
assign HEX1 = numdisp(DRAM_DQ[7:4]);
assign HEX2 = numdisp(DRAM_DQ[11:8]);
assign HEX3 = numdisp(DRAM_DQ[15:12]);
//assign {DRAM_CS_N, DRAM_RAS_N, DRAM_CAS_N, DRAM_WE_N} = command;
//assign DRAM_DQ = DRAM_DQ_temp;
always@(*) begin
LEDR[2:1] = (state == 5'd12)? 2'b01 : (state == 5'd6)? 2'b10 : 2'b00;
LEDR[0]= (SW[0]==1'b1) ? 1'b1:1'b0;
LEDR[3] = (data_in_ff == 16'hF045)? 1'b1: 1'b0;
LEDR[4] = (state == 5'd5 )?1'b1:1'b0; //NOP state where it is waiting for key input for read and write operations
LEDR[5] = KEY[0];
data_in= data_in_ff;
DRAM_BA = 2'b11;
LEDR[6]=1'b0;
DRAM_CKE=1'b0;
DRAM_UDQM = 1'b1;
DRAM_LDQM = 1'b1;
DRAM_ADDR = 13'hFFFF;
DRAM_DQ=16'bzzzzzzzzzzzzzzzz;
nstate =state;
case(state)
5'b00000: begin //initial state
        DRAM_CKE = 1'b1;
		  DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  nstate = (init_count<20'd10000)? 5'b00000: 5'b00001;
		  end
5'b00001: begin //precharge state
        DRAM_CKE = 1'b1;
		  DRAM_RAS_N = 1'b0;
        DRAM_WE_N = 1'b0;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  DRAM_BA[0] = 1'b0;//precharging both the banks
		  DRAM_BA[1] = 1'b0;
		  DRAM_ADDR[10] = 1'b1;
		  nstate = (precharge_count < 2'd2) ? 5'b00001 : 5'b00010;
		  end
5'b00010: begin  // Refresh state: At least  8 refresh cycles are required and time duration between each REF to REF is min. 60ns
		  DRAM_CKE = 1'b1;
		  DRAM_RAS_N = 1'b0;
		  DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b0;
		  nstate = 4'b0011;
        end
5'b00011: begin //NOP
        DRAM_CKE = 1'b1;
		  DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  nstate = (refresh_count < 4'd8)? ((nop_count<3'd4)? 5'b00011 : 5'b00010) : 5'b00100;  // 4 NOP cycles gives 80ns delay whereas min 60ns delay is required
		  end
5'b00100: begin //mode regester select state
        DRAM_CKE = 1'b1;
		  DRAM_RAS_N = 1'b0;
        DRAM_WE_N = 1'b0;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b0;
		  DRAM_BA[0] = 1'b0;
		  DRAM_BA[1] = 1'b0;
		  DRAM_ADDR = {1'b0,1'b0,1'b0,1'b1,2'b00,3'b010,1'b1,3'b000};
		  nstate = 5'b00101;
			end
5'b00101: begin //NOP 
        DRAM_CKE = 1'b1;
		  DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  nstate = (SW[1] == 1'b1 && SW[2] == 1'b0 && SW[3] == 1'b0) ? 5'b01100 : (SW[1] == 1'b0 && SW[2] == 1'b1 && SW[3]==1'b0)? 5'b00110 : (SW[1] == 1'b0 && SW[2] == 1'b0 && SW[3]==1'b1)?  5'b10100:5'b00101;
		  end
5'b00110: begin //Active state for read
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b0;
		  DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  DRAM_ADDR =  {1'b0,1'b0,1'b0,1'b0,1'b0,8'h05}; //here A10 is 0
		  DRAM_BA[0] = 1'b0;
		  DRAM_BA[1] = 1'b1;
		  nstate = 5'b00111;
		  end
	
5'b00111: begin //NOP 
        DRAM_CKE = 1'b1;
		  DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  nstate = 5'b01000;
		  end
		  
5'b01000: begin //NOP 
		  DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  nstate = 5'b01001;
		  end
	
5'b01001: begin //read
        DRAM_CKE = 1'b1;  
        DRAM_RAS_N = 1'b1;
		  DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b0;
		  DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
		  DRAM_BA[0] = 1'b0;
		  DRAM_BA[1] = 1'b1;
		  DRAM_ADDR =  {1'b0,1'b0,1'b1,1'b0,1'b0,8'h05};
		  nstate = 5'b01010;
       end
5'b01010: begin //NOP 
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  DRAM_CKE = 1'b1;
		  DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
		  nstate = 5'b01011;
		  end	  
5'b01011: begin //NOP 
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  DRAM_CKE = 1'b1;
		  DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
		  data_in = DRAM_DQ;
		  nstate = 5'b00101; //5'b11001;//
		  end		 
5'b01100: begin //Active state for write
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b0;
		  DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  DRAM_ADDR =  {1'b0,1'b0,1'b0,1'b0,1'b0,8'h05}; //here A10 is 0
		  DRAM_BA[0] = 1'b0;
		  DRAM_BA[1] = 1'b1;
		  nstate = 5'b01101;
		  end
	
5'b01101: begin //NOP 
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  nstate = 5'b01110;
		  end
		  
5'b01110: begin //NOP 
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
		  nstate = 5'b01111;
		  end
5'b01111: begin //write
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b1;
		  DRAM_WE_N = 1'b0;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b0;
		  DRAM_BA[0] = 1'b0;
		  DRAM_BA[1] = 1'b1;
		  DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
		  DRAM_ADDR =  {1'b0,1'b0,1'b1,1'b0,1'b0,8'h05};
		  DRAM_DQ = 16'h7528;
		  nstate = 5'b10010;
		  end
5'b10001: begin //NOP 
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  DRAM_UDQM = 1'b1;
        DRAM_LDQM = 1'b1;
		  nstate = 5'b10011;
		  end
5'b10010: begin //write
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b1;
		  DRAM_WE_N = 1'b0;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b0;
		  DRAM_BA[0] = 1'b0;
		  DRAM_BA[1] = 1'b1;
		  DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
		  DRAM_ADDR =  {1'b0,1'b0,1'b1,1'b0,1'b0,8'h07};
		  DRAM_DQ = 16'h3297;
		  LEDR[6] = 1'b1;
		  nstate = 5'b10011;
		  end
5'b10011: begin //NOP
        DRAM_CKE = 1'b0;
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  nstate = 5'b00101;
		  end
//Next address read	  

5'b10100: begin //Active state for read
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b0;
		  DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  DRAM_ADDR =  {1'b0,1'b0,1'b0,1'b0,1'b0,8'h05}; //here A10 is 0
		  DRAM_BA[0] = 1'b0;
		  DRAM_BA[1] = 1'b1;
		  nstate = 5'b10101;
		  end
	
5'b10101: begin //NOP 
        DRAM_CKE = 1'b1;
		  DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  nstate = 5'b10110;
		  end
		  
5'b10110: begin //NOP 
		  DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  nstate = 5'b10111;
		  end
	
5'b10111: begin //read
        DRAM_CKE = 1'b1;  
        DRAM_RAS_N = 1'b1;
		  DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b0;
		  DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
		  DRAM_BA[0] = 1'b0;
		  DRAM_BA[1] = 1'b1;
		  DRAM_ADDR =  {1'b0,1'b0,1'b1,1'b0,1'b0,8'h07};
		  nstate = 5'b11000;
       end
5'b11000: begin //NOP 
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  DRAM_CKE = 1'b1;
		  DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
		  nstate = 5'b11001;
		  end	  
5'b11001: begin //NOP 
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  DRAM_CKE = 1'b1;
		  DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
		  data_in = DRAM_DQ;
		  nstate = 5'b00101;
		  end		 
endcase
end

always@(posedge clk or negedge rst) begin
  if(!rst) begin
  state<=0;
  data_in_ff <= 16'd0;
  init_count <=0;
  refresh_count <= 0;
  nop_count<=0;
  precharge_count <= 0;
  end
 else begin
  state<=nstate;
  data_in_ff <= data_in; 
  init_count <= (state == 5'd0)? ((init_count<20'd10000)? (init_count + 1'b1) : init_count): init_count;
  precharge_count <= (state == 5'b00001)? ((precharge_count < 2'd2) ? (precharge_count + 1'b1) : precharge_count) : precharge_count;
  refresh_count <= (state == 5'b00010) ? ((refresh_count < 4'd8) ? (refresh_count + 1'b1) : refresh_count) : refresh_count; 
  nop_count <= (state == 5'b00011) ? ((nop_count< 3'd4) ? (nop_count + 1'b1) : 3'd0) : nop_count;
 end
end


function [7:0] numdisp;
        input [3:0] num;
        case (num)
            0: begin
                numdisp= 8'b11000000;
            end
            1: begin
                numdisp= 8'b11111001;
            end
            2: begin
                numdisp= 8'b10100100;
            end
            3: begin
                numdisp= 8'b10110000;
            end 
            4: begin
                numdisp= 8'b10011001;
            end
            5: begin
                numdisp= 8'b10010010;
            end
            6: begin
                numdisp= 8'b10000010;
            end
            7: begin
                numdisp= 8'b11111000;
            end
            8: begin
                numdisp= 8'b10000000;
            end
            9: begin
                numdisp= 8'b10011000;
            end
            10: begin
                numdisp= 8'b10001000;
            end
            11: begin
                numdisp= 8'b10000011;
                end
            12: begin
                numdisp= 8'b11000110;
                end
            13: begin
                numdisp= 8'b10100001;
                end
            14: begin
                numdisp= 8'b10000110;
                end
            15: begin
                numdisp= 8'b10001110;
                end
        endcase
endfunction




endmodule
