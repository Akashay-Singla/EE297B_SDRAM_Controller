// ============================================================================
//   Ver  :| Author					:| Mod. Date :| Changes Made:
//   V1.1 :| Alexandra Du			:| 06/01/2016:| Added Verilog file
// ============================================================================


//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================


module DE10_LITE_Golden_Top(
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,
	output reg	    [12:0]		DRAM_ADDR,
	output reg	    [1:0]		DRAM_BA,
	output reg		          	DRAM_CAS_N,
	output reg		          	DRAM_CKE,
	output    	               DRAM_CLK,
	output reg           		DRAM_CS_N,
	inout  reg  	[15:0]	   DRAM_DQ,
	output reg	          		DRAM_LDQM,
	output reg            	   DRAM_RAS_N,
	output reg	          		DRAM_UDQM,
	output reg	            	DRAM_WE_N,
	output		    [7:0]		HEX0,
	output		    [7:0]		HEX1,
	output		    [7:0]		HEX2,
	output		    [7:0]		HEX3,
	output		    [7:0]		HEX4,
	output		    [7:0]		HEX5,
	input 		     [1:0]		KEY,
	output	reg	  [9:0]		LEDR,
	input 		     [9:0]		SW,
	inout 		          		ARDUINO_RESET_N,
	inout 		    [35:0]		GPIO
);
reg [3:0] command; 
reg [4:0] state,nstate;
reg [15:0] data_in;
reg [31:0] write_data;
reg [9:0] write_addr_col;
reg [12:0] addr_row;
reg [9:0] read_addr_col;
reg [15:0] read_data;
reg [12:0] addr;
reg [19:0] init_count;
reg [1:0] precharge_count;
reg [3:0] refresh_count;
reg [2:0] nop_count;
wire clk,rst;
reg read_LED1, read_LED2,read_LED3, read_LED4,read_LED5,read_LED6;
wire [31:0] master_address; //output
reg [31:0] master_readdata; //input
wire master_read; //output
wire master_write; //output
wire master_reset;//output
wire [31:0] master_writedata;//output
reg master_waitrequest;//input
reg master_readdatavalid;//input
wire [3:0] master_byteenable;//output
reg rstate_ready,fpa_start,fpa_data_ready1,fpa_data_ready2,fifo_data_ready;
wire [15:0]FPSUM_34;
wire Ovf_Flag_34,Unf_Flag_34;
reg [15:0] Finput1_34,Finput2_34,fifo_data_in,Finput1_temp;
wire [15:0]fifo_data_out;
reg fifo_push,fifo_pull, fifo_pull2,data_ready, fifo_data_ready_temp;
wire fifo_empty,fifo_full;
reg [31:0] fpa_read_addr;





assign DRAM_CLK = MAX10_CLK1_50;
assign clk = MAX10_CLK1_50;
assign rst = KEY[0];
assign HEX0 = numdisp(FPSUM_34[3:0]);
assign HEX1 = numdisp(FPSUM_34[7:4]);
assign HEX2 = numdisp(FPSUM_34[11:8]);
assign HEX3 = numdisp(FPSUM_34[15:12]);
//assign HEX0 = numdisp(DRAM_DQ[3:0]);
//assign HEX1 = numdisp(DRAM_DQ[7:4]);
//assign HEX2 = numdisp(DRAM_DQ[11:8]);
//assign HEX3 = numdisp(DRAM_DQ[15:12]);
assign HEX4 = numdisp(Finput1_34[3:0]);
assign HEX5 = numdisp(Finput2_34[3:0]);

//=======================================================
// sys console declarations
//=======================================================
fpa_adder fpa0(clk,rst,Finput1_34,Finput2_34,FPSUM_34,Ovf_Flag_34,Unf_Flag_34);
fifo_design fifo0 (clk,rst,fifo_data_in,fifo_push,fifo_pull,fifo_data_out,fifo_empty,fifo_full);
sys_console u1(
		MAX10_CLK1_50, //      clk
		MAX10_CLK1_50, //     clk
		~rst,//KEY[0],      //reset
		master_address,       //    output   master_0_master.address
		master_readdata,      //input .readdata
		master_read,          //output .read
		master_write,         //.write
		master_writedata,     //.writedata
		master_waitrequest,   //.waitrequest
		master_readdatavalid, //.readdatavalid
		master_byteenable,    //.byteenable
	   master_reset,   // output 
		~rst//KEY[0]   // input  
);


always@(*) begin
LEDR[0] = (state == 5'd5 )?1'b1:1'b0; //NOP state where it is waiting for key input for read and write operations
LEDR[1] = read_LED1;
LEDR[2] = read_LED2;
LEDR[3] = read_LED3;
LEDR[4] = read_LED4;
LEDR[5] = read_LED5;
LEDR[6] = read_LED6;
DRAM_BA = 2'b11;
DRAM_CKE=1'b0;
DRAM_UDQM = 1'b1;
DRAM_LDQM = 1'b1;
DRAM_ADDR = 13'hFFFF;
DRAM_DQ=16'bzzzzzzzzzzzzzzzz;
data_ready = 1'b0;
nstate =state;
rstate_ready=1'b0;
fpa_data_ready1=1'b0;
fpa_data_ready2=1'b0;
case(state)
5'b00000: begin //initial state
        DRAM_CKE = 1'b1;
		DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		nstate = (init_count<20'd10000)? 5'b00000: 5'b00001;
		  end
5'b00001: begin //precharge state
        DRAM_CKE = 1'b1;
		DRAM_RAS_N = 1'b0;
        DRAM_WE_N = 1'b0;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		DRAM_BA[0] = 1'b0;//precharging both the banks
		DRAM_BA[1] = 1'b0;
		DRAM_ADDR[10] = 1'b1;
		nstate = (precharge_count < 2'd2) ? 5'b00001 : 5'b00010;
		  end
5'b00010: begin  // Refresh state: At least  8 refresh cycles are required and time duration between each REF to REF is min. 60ns
		  DRAM_CKE = 1'b1;
		  DRAM_RAS_N = 1'b0;
		  DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b0;
		  nstate = 5'b00011;
        end
5'b00011: begin //NOP
        DRAM_CKE = 1'b1;
		DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		nstate = (refresh_count < 4'd8)? ((nop_count<3'd4)? 5'b00011 : 5'b00010) : 5'b00100;  // 4 NOP cycles gives 80ns delay whereas min 60ns delay is required
		  end
5'b00100: begin //mode regester select state
          DRAM_CKE = 1'b1;
		  DRAM_RAS_N = 1'b0;
          DRAM_WE_N = 1'b0;
          DRAM_CS_N = 1'b0;
          DRAM_CAS_N = 1'b0;
		  DRAM_BA[0] = 1'b0;
		  DRAM_BA[1] = 1'b0;
		  DRAM_ADDR = {1'b0,1'b0,1'b0,1'b0,2'b00,3'b010,1'b0,3'b001};
		  nstate = 5'b00101;
			end
5'b00101: begin //NOP 
        DRAM_CKE = 1'b1;
		DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		nstate = (master_write==1'b1 && master_address != 32'h00008000)? 5'b01101 : (master_read==1'b1 && (master_address != 32'h00008000)) ? 5'b00110 : 
                (fpa_start == 1'b1)? 5'b10010 :5'b00101;
		  end
5'b00110: begin //Active state for read
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b0;
		DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		DRAM_ADDR =  addr_row;
		DRAM_BA[0] = 1'b0;
		DRAM_BA[1] = 1'b1;
		nstate = 5'b00111;
		  end
	
5'b00111: begin //NOP 
        DRAM_CKE = 1'b1;
		DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		nstate = 5'b01000;
		  end
		  
5'b01000: begin //NOP 
		DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		nstate = 5'b01001;
		  end
	
5'b01001: begin //read
        DRAM_CKE = 1'b1;  
        DRAM_RAS_N = 1'b1;
		DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b0;
		DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
		DRAM_BA[0] = 1'b0;
		DRAM_BA[1] = 1'b1;
		DRAM_ADDR = {1'b0,1'b0, 1'b0,read_addr_col};
        nstate = 5'b01010;
       end
5'b01010: begin //NOP 
        DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		DRAM_CKE = 1'b1;
		nstate = 5'b01011;
		  end	  
5'b01011: begin //NOP with read burst 1
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		DRAM_CKE = 1'b1;
		DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
        rstate_ready = 1'b1;
		nstate = 5'b01100;
		  end
5'b01100: begin //NOP with read burst 2
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		DRAM_CKE = 1'b1;
		DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
        data_ready = 1'b1;
		nstate =  5'b00101; 
		  end			 
5'b01101: begin //Active state for write
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b0;
		  DRAM_WE_N = 1'b1;
          DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		  DRAM_ADDR =  addr_row;
		  DRAM_BA[0] = 1'b0;
		  DRAM_BA[1] = 1'b1;
		  nstate = 5'b01110;
		  end
	
5'b01110: begin //NOP 
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		nstate = 5'b01111;
		  end
		  
5'b01111: begin //NOP 
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
		nstate = 5'b10000;
		  end
5'b10000: begin //write with burst 1
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b1;
		DRAM_WE_N = 1'b0;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b0;
		DRAM_BA[0] = 1'b0;
		DRAM_BA[1] = 1'b1;
		DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
		DRAM_ADDR =  {1'b0,1'b0,1'b0,write_addr_col}; 
		DRAM_DQ = write_data[15:0];
		nstate = 5'b10001;
		end
5'b10001: begin //NOP write burst
        DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
        DRAM_BA[0] = 1'b0;
		DRAM_BA[1] = 1'b1;
        DRAM_CKE = 1'b0;
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
        DRAM_DQ = write_data[31:16];
		nstate = 5'b00101;
		  end	 
5'b10010: begin //Active state for read for FPA
        DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b0;
		DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		DRAM_ADDR =  fpa_read_addr[12:0];
		DRAM_BA[0] = 1'b0;
		DRAM_BA[1] = 1'b1;
		nstate = 5'b10011;
		  end
	
5'b10011: begin //NOP for FPA
        DRAM_CKE = 1'b1;
		DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		nstate = 5'b10100;
		  end
		  
5'b10100: begin //NOP for FPA
		DRAM_CKE = 1'b1;
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		nstate = 5'b10101;
		  end
	
5'b10101: begin //read for FPA
        DRAM_CKE = 1'b1;  
        DRAM_RAS_N = 1'b1;
		DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b0;
		DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
		DRAM_BA[0] = 1'b0;
		DRAM_BA[1] = 1'b1;
		DRAM_ADDR = {1'b0,1'b0, 1'b0,fpa_read_addr[25:16]};
        nstate = 5'b10110;
       end
5'b10110: begin //NOP  for FPA
        DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		DRAM_CKE = 1'b1;
		nstate = 5'b10111;
		  end	  
5'b10111: begin //NOP with read burst 1 for FPA
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		DRAM_CKE = 1'b1;
		DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
        fpa_data_ready1 = 1'b1;
		nstate = 5'b11000;
		  end
5'b11000: begin //NOP with read burst 2 for FPA
        DRAM_RAS_N = 1'b1;
        DRAM_WE_N = 1'b1;
        DRAM_CS_N = 1'b0;
        DRAM_CAS_N = 1'b1;
		DRAM_CKE = 1'b1;
		DRAM_UDQM = 1'b0;
        DRAM_LDQM = 1'b0;
        fpa_data_ready2 = 1'b1;
		nstate =  5'b00101; 
		  end	
    
endcase
end

always@(posedge clk or negedge rst) begin
  if(!rst) begin
  state <= 0;
  data_in <= 0;
  init_count <= 0;
  refresh_count <= 0;
  nop_count <= 0;
  precharge_count <= 0;
  read_LED1 <= 1'b0;
  read_LED2 <= 1'b0;
  read_LED3 <= 1'b0;
  read_LED4 <= 1'b0;
  read_LED5 <= 1'b0; read_LED6 <= 0;
  master_readdata <= 16'h0000;
  master_readdatavalid <= 1'b0;
  master_waitrequest <= 1'b0;
  write_addr_col <= 0;
  write_data <= 0;
  addr_row <= 0;
  read_addr_col <= 0;
  fpa_start <= 0;
  fpa_read_addr <= 0;
  fifo_pull2 <= 0;
  fifo_pull <=0; 
  fifo_push <=0;
  fifo_data_in<=0; fifo_data_ready <=0;fifo_data_ready_temp <=0;
  Finput1_34 <=0; Finput2_34 <= 0; Finput1_temp <=0;
  end
 else begin
  state  <= nstate;
  init_count <= (state == 5'd0)? ((init_count<20'd10000)? (init_count + 1'b1) : init_count): init_count;
  precharge_count <= (state == 5'b00001)? ((precharge_count < 2'd2) ? (precharge_count + 1'b1) : precharge_count) : precharge_count;
  refresh_count <= (state == 5'b00010) ? ((refresh_count < 4'd8) ? (refresh_count + 1'b1) : refresh_count) : refresh_count; 
  nop_count <= (state == 5'b00011) ? ((nop_count< 3'd4) ? (nop_count + 1'b1) : 3'd0) : nop_count;
  read_LED1 <= Unf_Flag_34;//(Unf_Flag_34)? 1'b1 : read_LED1;
  read_LED2 <= fifo_full;//(master_write)? 1'b1 : read_LED2;
  read_LED3 <= fifo_push;//(fifo_push) ? 1'b1: read_LED3;
  read_LED4 <= fifo_pull;//(fifo_pull) ? 1'b1: read_LED4;
  read_LED5 <= fifo_empty;//(Unf_Flag_34) ? 1'b1: read_LED5;
  read_LED6 <= Ovf_Flag_34;
    write_addr_col <= ((master_write==1'b1) && (master_address != 32'h00008000))? master_address[25:16] : write_addr_col;
	write_data <= ((master_write==1'b1) && (master_address != 32'h00008000)) ? master_writedata : write_data;
	addr_row <= master_address[12:0];
    read_addr_col <= ((master_read == 1'b1) && (master_address != 32'h00008000))? master_address[25:16]: read_addr_col;
	master_readdatavalid <= (data_ready==1'b1 || fifo_pull2==1'b1)? 1'b1: 1'b0;
    data_in <= (rstate_ready)? DRAM_DQ : data_in;
    master_readdata <= (data_ready)? {DRAM_DQ,data_in}: (fifo_pull2 == 1'b1) ? {16'h0000, fifo_data_out} : 0;

	master_waitrequest <= (master_write == 1'b1 || data_ready == 1'b1 || fifo_pull2 == 1'b1 ) ? 1'b0 : 1'b1;
    Finput1_temp <= (fpa_data_ready1) ? DRAM_DQ : Finput1_temp;
    Finput1_34 <= Finput1_temp;
    fifo_push <= (fifo_data_ready && Unf_Flag_34==1'b0 && Ovf_Flag_34==1'b0 && fifo_full==1'b0)? 1'b1: 1'b0;
    fifo_pull <= ((master_read == 1'b1) && (master_address == 32'h00008000))? 1'b1 : 1'b0;
    fifo_pull2 <= fifo_pull;
    fifo_data_ready_temp <= fpa_data_ready2;
    fifo_data_ready <= fifo_data_ready_temp;//FPA gives ouput in one clock cycle
    fifo_data_in <= FPSUM_34; 
    Finput2_34 <= (fpa_data_ready2)? DRAM_DQ : Finput2_34; 
    fpa_start <= (master_write)? ((master_address == 32'h00008000)? 1'b1 : 1'b0): 1'b0;  
    fpa_read_addr <= (master_address == 32'h00008000)? master_writedata : fpa_read_addr;
 end
end

function [7:0] numdisp;
        input [3:0] num;
        case (num)
            0: begin
                numdisp= 8'b11000000;
            end
            1: begin
                numdisp= 8'b11111001;
            end
            2: begin
                numdisp= 8'b10100100;
            end
            3: begin
                numdisp= 8'b10110000;
            end 
            4: begin
                numdisp= 8'b10011001;
            end
            5: begin
                numdisp= 8'b10010010;
            end
            6: begin
                numdisp= 8'b10000010;
            end
            7: begin
                numdisp= 8'b11111000;
            end
            8: begin
                numdisp= 8'b10000000;
            end
            9: begin
                numdisp= 8'b10011000;
            end
            10: begin
                numdisp= 8'b10001000;
            end
            11: begin
                numdisp= 8'b10000011;
                end
            12: begin
                numdisp= 8'b11000110;
                end
            13: begin
                numdisp= 8'b10100001;
                end
            14: begin
                numdisp= 8'b10000110;
                end
            15: begin
                numdisp= 8'b10001110;
                end
        endcase
endfunction
endmodule
